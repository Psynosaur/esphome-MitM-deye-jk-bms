# Man In The (middle) Deye
# Read Deye Protocol from BMS and send to inverter with some modifications

substitutions:
  name: mitm-deye
  device_description: "Man In The Middle Adapter For Deye Communication Protocol"

# voltage offset for inverter to compensate voltage drop in cabling or to force inverter (e.g. Deye) to go higher with a voltage to reach charge voltage level
  offset_voltage: "0.4"

#BMS specific:
  charge_current: "200"
  discharge_current: "200"


esphome:
  name: ${name}
  friendly_name: ${name}
  comment: ${device_description}
  # min_version: 2024.7.0 # for ESP32 C6

# esp32:
#   board: featheresp32
#   framework:
#     type: arduino

esp32:
# ESP32 C6
  board: esp32-c6-devkitc-1
  flash_size: 8MB
  variant: esp32c6
  framework:
    type: esp-idf
    version: "5.2.2"
    platform_version: 6.6.0
    sdkconfig_options:
      CONFIG_OPENTHREAD_ENABLED: n
      CONFIG_ENABLE_WIFI_STATION: y
      CONFIG_USE_MINIMAL_MDNS: y
      CONFIG_ESPTOOLPY_FLASHSIZE_8MB: y
      CONFIG_ESP_CONSOLE_USB_CDC: y
      
# for ESP32 C6 only because of two CAN-busses
external_components:
  - source: github://Adminius/esphome@multiple_can_esp32
    components: [ esp32_can ]
#    refresh: 60s
# Enable logging
logger:
  baud_rate: 0 # disable UART logger
  level: INFO

# Enable webserver
web_server:
  port: 80
  auth:
    username: admin
    password: !secret wifi_password
  version: 3
  log: true
  ota: false

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_key_mit

ota:
  - platform: esphome
    password: !secret ota_key_mit

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

#mqtt:
#  topic_prefix: ${name}
#  discovery: false
#  broker: !secret mqtt_broker
#  port: !secret mqtt_port
#  username: !secret mqtt_user
#  password: !secret mqtt_password
#  discovery_prefix: !secret mqtt_discovery_prefix


globals:
  - id: can305Counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: noBmsUpdateCounter
    type: int
    restore_value: no
    initial_value: '0'
  - id: force100soc
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: saveRcv
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: invSoc
    type: int
    restore_value: no
    initial_value: '0'
  - id: last_invSoc
    type: int
    restore_value: yes
    initial_value: '0'
  - id: last_jk_soc
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: last_pack1_soc
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: last_pack2_soc
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: jk_unavailable_count
    type: int
    initial_value: '0'
  - id: pack1_unavailable_count
    type: int
    initial_value: '0'
  - id: pack2_unavailable_count
    type: int
    initial_value: '0'

time:
# charge battery to 100% each sunday to calibrate cells and BMS
  - platform: sntp
    on_time:
    - seconds: 00
      minutes: 00
      hours: 11
      days_of_week: SUN
      then:
        lambda: |-
          id(force100soc) = true;

# for MCP2515
# spi:
#  miso_pin: GPIO27
#  mosi_pin: GPIO26
#  clk_pin: GPIO25

canbus:

# inverter
# ESP32 C6:
  - platform: esp32_can
    id: inverter
    tx_pin: GPIO01
    rx_pin: GPIO00
    can_id: 100
    bit_rate: 500KBPS
    on_frame:
    - can_id: 0x305
      then:
        - lambda: |-
            id(can305Counter) = 0;  //inverter is connected
            id(inverter_connected).publish_state(true);
            //ESP_LOGI("main", "received can id: 0x305 ACK");

# NOT TESTED:
  # - platform: esp32_can
  #   id: bms
  #   tx_pin: GPIO32 # CAN HIGH BLUE
  #   rx_pin: GPIO39 # CAN LOW LIGHT BLUE
  #   can_id: 100
  #   bit_rate: 500KBPS
  #   on_frame:
  #   - can_id: 0x305
  #     then:
  #       - lambda: |-
  #           id(can305Counter) = 0;  //inverter is connected
  #           id(inverter_connected).publish_state(true);
  #           ESP_LOGI("main", "received can id: 0x305 ACK");


# BMS
  # - platform: mcp2515
  #   id: inverter
  #   cs_pin: GPIO33
  - platform: esp32_can
    id: bms
    tx_pin: GPIO02
    rx_pin: GPIO03
    can_id: 200
    bit_rate: 500KBPS
    on_frame:
#    - can_id: 0
#      can_id_mask: 0
#      then:
#        - lambda: |-
#            ESP_LOGI("BMS:", "0x%x%02x: %02x %02x %02x %02x %02x %02x %02x %02x", (uint8_t)(can_id >> 8), (uint8_t)(can_id & 0xFF), x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]);
    # Battery charging voltage and current limits
    - can_id: 0x351 
      then:
        - lambda: |-
            float u_max = ((x[1] << 8) | x[0]) / 10.0;
            id(battery_charge_voltage).publish_state(u_max); // 58.4V

            // assume, that the highest voltage is RCV! 
            // Attention!!! if RCV will be changed to lower voltage in BMS, reboot of mitpylon device is necessary!!!
            if(id(saveRcv) < u_max) id(saveRcv) = id(charge_voltage_override).state; 

            uint16_t chargeCurrent = ((x[3] << 8) | x[2]) / 10;
            id(battery_charge_current_limit).publish_state(chargeCurrent);

            uint16_t dischargeCurrent = ((x[5] << 8) | x[4]) / 10;
            id(battery_discharge_current_limit).publish_state(dischargeCurrent);

            id(noBmsUpdateCounter) = 0;  //bms is connected
            id(bms_connected).publish_state(true);

            uint8_t canMessage[] = {0x00, 0x00, x[2], x[3], x[4], x[5], x[6], x[7]};
            
            uint16_t chargeVoltage = (uint16_t)((id(charge_voltage_override).state - id(charge_voltage_offset).state) * 10);
            canMessage[0] = chargeVoltage & 0xFF;
            canMessage[1] = chargeVoltage >> 8;

            // Lower charge limit if slider value is lower than `chargeCurrent`
            if(id(set_charge_current_limit).state <= chargeCurrent) { 
              chargeCurrent = (uint16_t)(id(set_charge_current_limit).state) * 10; 
              canMessage[2] = (uint8_t)(chargeCurrent & 0xFF);
              canMessage[3] = (uint8_t)(chargeCurrent >> 8);
            }

            // Modify charge current sent to inverter if override is enabled
            if (id(use_charge_current_override).state) {
              // scale slider (A → raw) and split into LSB/MSB
              uint16_t oc = (uint16_t)(id(set_charge_current_limit).state * 10);
              canMessage[2] = oc & 0xFF;
              canMessage[3] = oc >> 8;
              ESP_LOGI("0x371", "Override active - sending %u (raw)", oc);
            }
            
            // Set charge current to `0`
            if(!id(charging_allowed).state || !id(set_charging_allowed).state) {
              /* if charging is not allowed, set current to 0*/
              canMessage[2] = 0x00;
              canMessage[3] = 0x00;
            }

            // Lower discharge limit if slider value is lower than `dischargeCurrent`
            if(id(set_discharge_current_limit).state <= dischargeCurrent) {
                dischargeCurrent = (uint16_t)(id(set_discharge_current_limit).state) * 10;
                canMessage[4] = (uint8_t)(dischargeCurrent & 0xFF);
                canMessage[5] = (uint8_t)(dischargeCurrent >> 8);
            }

            std::vector< uint8_t > data{canMessage[0], canMessage[1], canMessage[2], canMessage[3], canMessage[4], canMessage[5], canMessage[6], canMessage[7]};
            
            id(inverter)->send_data(can_id, false, data);
            //ESP_LOGI("canid 0x351:", "U_max: %.1f V, I_charge %d A, I_discharge: %d A", u_max, chargeCurrent / 10, dischargeCurrent / 10);

    - can_id: 0x355
      then:
        - lambda: |-
            int soc = ((x[1] << 8) | x[0]);
            id(battery_soc).publish_state(soc);
            int soh = ((x[3] << 8) | x[2]);
            id(battery_soh).publish_state(soh);
            
            // Track availability of each SOC source
            bool jk_available = id(jk_bms_soc).has_state();
            bool pack1_available = id(pack_1_soc).has_state();
            bool pack2_available = id(pack_2_soc).has_state();
            
            // Update availability counters
            id(jk_unavailable_count) = jk_available ? 0 : min(100, id(jk_unavailable_count) + 1);
            id(pack1_unavailable_count) = pack1_available ? 0 : min(100, id(pack1_unavailable_count) + 1);
            id(pack2_unavailable_count) = pack2_available ? 0 : min(100, id(pack2_unavailable_count) + 1);
            
            // Read available SOC values as floats with fallback to last known values
            float new_jk_soc = jk_available ? id(jk_bms_soc).state : id(last_jk_soc);
            float new_pack1_soc = pack1_available ? id(pack_1_soc).state : id(last_pack1_soc);
            float new_pack2_soc = pack2_available ? id(pack_2_soc).state : id(last_pack2_soc);

            // Log raw values for debugging
            ESP_LOGI("SOC Raw Values",
                    "JK: %.1f%% (%s), Pack1: %.1f%% (%s), Pack2: %.1f%% (%s)",
                    new_jk_soc, jk_available ? "Available" : "Unavailable",
                    new_pack1_soc, pack1_available ? "Available" : "Unavailable",
                    new_pack2_soc, pack2_available ? "Available" : "Unavailable");

            // Apply filtering to each SOC value
            // Allow updates if: first reading (last == 0.0), new value is 0%, or within 2% tolerance
            if (jk_available) {
              bool should_update = (id(last_jk_soc) == 0.0 || new_jk_soc == 0.0 || abs(new_jk_soc - id(last_jk_soc)) <= 2.0);
              ESP_LOGI("SOC Filter", "JK: last=%.1f, new=%.1f, diff=%.1f, update=%s",
                      id(last_jk_soc), new_jk_soc, abs(new_jk_soc - id(last_jk_soc)), should_update ? "YES" : "NO");
              if (should_update) {
                id(last_jk_soc) = new_jk_soc;
              }
            }
            if (pack1_available) {
              bool should_update = (id(last_pack1_soc) == 0.0 || new_pack1_soc == 0.0 || abs(new_pack1_soc - id(last_pack1_soc)) <= 2.0);
              ESP_LOGI("SOC Filter", "Pack1: last=%.1f, new=%.1f, diff=%.1f, update=%s",
                      id(last_pack1_soc), new_pack1_soc, abs(new_pack1_soc - id(last_pack1_soc)), should_update ? "YES" : "NO");
              if (should_update) {
                id(last_pack1_soc) = new_pack1_soc;
              }
            }
            if (pack2_available) {
              bool should_update = (id(last_pack2_soc) == 0.0 || new_pack2_soc == 0.0 || abs(new_pack2_soc - id(last_pack2_soc)) <= 2.0);
              ESP_LOGI("SOC Filter", "Pack2: last=%.1f, new=%.1f, diff=%.1f, update=%s",
                      id(last_pack2_soc), new_pack2_soc, abs(new_pack2_soc - id(last_pack2_soc)), should_update ? "YES" : "NO");
              if (should_update) {
                id(last_pack2_soc) = new_pack2_soc;
              }
            }
            
            // Determine which values to use in calculation based on availability
            float jk_to_use = (id(jk_unavailable_count) < 100) ? id(last_jk_soc) : -1.0;
            float pack1_to_use = (id(pack1_unavailable_count) < 100) ? id(last_pack1_soc) : -1.0;
            float pack2_to_use = (id(pack2_unavailable_count) < 100) ? id(last_pack2_soc) : -1.0;

            // Calculate combined average from available sources
            int count = 0;
            float total = 0.0;

            if (jk_to_use != -1.0) {
              total += jk_to_use;
              count++;
            }
            if (pack1_to_use != -1.0) {
              total += pack1_to_use;
              count++;
            }
            if (pack2_to_use != -1.0) {
              total += pack2_to_use;
              count++;
            }

            // If no sources available, use a safe default (50%)
            // Use proper rounding instead of truncation
            int combined = (count > 0) ? (int)round(total / count) : 50;
            
            // Apply 1% hack to the combined value
            if (combined == 1) {
              combined = 2;
            }
            
            // Update invSoc with the combined value
            id(invSoc) = combined;
            
            // Prepare SOC bytes for CAN message
            uint8_t socByte0 = combined & 0xFF;
            uint8_t socByte1 = (combined >> 8) & 0xFF;
            
            // Log values for debugging
            ESP_LOGI("SOC Monitoring",
                    "JK: %.1f%% (%s), Pack1: %.1f%% (%s), Pack2: %.1f%% (%s), Combined: %d%%",
                    id(last_jk_soc),
                    (id(jk_unavailable_count) < 100) ? "Available" : "Unavailable",
                    id(last_pack1_soc),
                    (id(pack1_unavailable_count) < 100) ? "Available" : "Unavailable",
                    id(last_pack2_soc),
                    (id(pack2_unavailable_count) < 100) ? "Available" : "Unavailable",
                    combined);
            
            // Send the CAN message
            std::vector<uint8_t> data{socByte0, socByte1, x[2], x[3], x[4], x[5], x[6], x[7]};
            id(inverter)->send_data(can_id, false, data);

    - can_id: 0x356
      then:
        - lambda: |-
            float voltage = ((x[1] << 8) | x[0]) / 100.0;
            id(battery_voltage).publish_state(voltage);
            float current = ((x[3] << 8) | x[2]) / 10.0;
            if(x[3] > 0x80) current = uint16_t(~((x[3] << 8) | x[2]) + 1) / -10.0;
            id(battery_current).publish_state(current);
            float temperature = ((x[5] << 8) | x[4]) / 10;
            id(battery_temperature).publish_state(temperature);
            id(battery_power).publish_state(voltage * current);
            id(inverter)->send_data(can_id, false, x);
#            ESP_LOGI("canid 0x356:", "U: %.1f V, I: %.1f A, T: %.1f °C", voltage, current, temperature );

    - can_id: 0x35C
      then:
         - lambda: |-
            // Original state reporting remains
            id(charging_allowed).publish_state(x[0] & 0x80);
            id(discharging_allowed).publish_state(x[0] & 0x40);
            id(request_force_charge_1).publish_state(x[0] & 0x20);
            id(request_force_charge_2).publish_state(x[0] & 0x10);
            id(request_full_charge).publish_state(x[0] & 0x08);

            uint8_t message = 0x00;
            
            // Preserve charging/discharging allowed states
            if(id(charging_allowed).state && id(set_charging_allowed).state) message |= 0x80;
            if(id(discharging_allowed).state && id(set_discharging_allowed).state) message |= 0x40;

            // Force Charge 1 handling
            if(id(block_bms_force_charge_1).state) {
              // Completely block BMS's Force Charge 1, use override
              if(id(override_force_charge_1).state) message |= 0x20;
            } else {
              // Normal operation: BMS value or override
              if(id(override_force_charge_1).state || (x[0] & 0x20)) message |= 0x20;
            }

            // Force Charge 2 handling
            if(id(block_bms_force_charge_2).state) {
              // Completely block BMS's Force Charge 2, use override
              if(id(override_force_charge_2).state) message |= 0x10;
            } else {
              // Normal operation: BMS value or override
              if(id(override_force_charge_2).state || (x[0] & 0x10)) message |= 0x10;
            }

            // Preserve full charge request
            if(x[0] & 0x08) message |= 0x08;

            // Only send message if either:
            // 1. We're not blocking both force charges, OR
            // 2. There's other important data to send
            if(message != 0 || (x[1] != 0 || x[2] != 0 || x[3] != 0 || x[4] != 0 || x[5] != 0 || x[6] != 0 || x[7] != 0)) {
              std::vector< uint8_t > data{message, x[1], x[2], x[3], x[4], x[5], x[6], x[7]};
              id(inverter)->send_data(can_id, false, data);
            }
        # - lambda: |-
        #     id(charging_allowed).publish_state(x[0] & 0x80);
        #     id(discharging_allowed).publish_state(x[0] & 0x40);
        #     id(request_force_charge_1).publish_state(x[0] & 0x20);
        #     id(request_force_charge_2).publish_state(x[0] & 0x10);
        #     id(request_full_charge).publish_state(x[0] & 0x08);
        #     // for(uint8_t i = 0; i < 8; i++){ id(can35c)[i] = x[i]; }
        #     uint8_t message = 0x00;
        #     if(id(charging_allowed).state && id(set_charging_allowed).state) message = 0x80;
        #     if(id(discharging_allowed).state && id(set_discharging_allowed).state) message = message | 0x40;
        #     if(id(request_force_charge_1).state || id(set_charge_request).state) message = message | 0x20;
        #     if(id(request_force_charge_2).state) message = message | 0x10;
        #     if(id(request_full_charge).state) message = message | 0x08;
        #     if(message != 192) ESP_LOGI("canid 0x35C:", "%02x", message);
        #     std::vector< uint8_t > data{ message, x[1], x[2], x[3], x[4], x[5], x[6], x[7]};
        #     id(inverter)->send_data(can_id, false, data);
        #     //ESP_LOGI("canid 0x35C:", "%02x %02x %02x %02x %02x %02x %02x %02x", x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]);    
    
    - can_id: 0x359
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
            //ESP_LOGI("canid 0x359:", "%02x %02x %02x %02x %02x %02x %02x %02x", x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]); 

    - can_id: 0x35E
      then:
# Deye SUN12K uses the strange implementation, and uses 0x35E as protocol definition for own batteries
# e.g. "JK-BMS" will not be shown in Deye, but "PYLON". So, rewrite it to fixed "PYLON"
        - lambda: |-
            //std::vector< uint8_t > data{0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x00, 0x00, 0x00};
            id(inverter)->send_data(can_id, false, x);
            //ESP_LOGI("canid 0x35E:", "%02x %02x %02x %02x %02x %02x %02x %02x", x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]); 
    - can_id: 0x356
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x361
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
            //float cell_u_max = ((x[1] << 8) | x[0]) / 1000.0;
            //id(battery_max_cell_voltage_deye).publish_state(cell_u_max);
            //float cell_u_min = ((x[3] << 8) | x[2]) / 1000.0;
            //id(battery_min_cell_voltage_deye).publish_state(cell_u_min);
            //float temp_max = ((x[5] << 8) | x[4]) / 10.0;
            //id(battery_temp_max_deye).publish_state(temp_max);
            //float temp_min = ((x[7] << 8) | x[6]) / 10.0;
            //id(battery_temp_min_deye).publish_state(temp_min);
    
    - can_id: 0x363
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);

    - can_id: 0x364
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
            //id(module_amount_normal_state).publish_state(x[0]);
            //id(module_amount_charge_disabled).publish_state(x[1]);
            //id(module_amount_discharge_disabled).publish_state(x[2]);
            //id(module_amount_communication_disconnected).publish_state(x[3]);
            //id(module_amount).publish_state(x[4]);

    - can_id: 0x371
      then:
        - lambda: |-
            // Determine charge-current bytes
            uint8_t b0 = x[0];
            uint8_t b1 = x[1];
            if (id(use_charge_current_override).state) {
              // scale slider (A → raw) and split into LSB/MSB
              uint16_t oc = (uint16_t)(id(set_charge_current_limit).state * 10);
              b0 = oc & 0xFF;
              b1 = oc >> 8;
              ESP_LOGI("0x371", "Override active - sending %u (raw)", oc);
            }

            // Rebuild full 8-byte payload: [b0,b1, x[2]…x[7]]
            std::vector<uint8_t> data = {b0, b1, x[2], x[3], x[4], x[5], x[6], x[7]};

            // Send to inverter
            id(inverter)->send_data(can_id, false, data);
    - can_id: 0x110 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x111 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);  

    - can_id: 0x150 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);

    - can_id: 0x151 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);

    - can_id: 0x200 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    
    - can_id: 0x201 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);

    - can_id: 0x250
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x251 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x400 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x401 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x110 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x111 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x500
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x501 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x550
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);

    - can_id: 0x551
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x600
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x601 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x650
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x651 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x700
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x701 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x750
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);
    - can_id: 0x751 
      then:
        - lambda: |-
            id(inverter)->send_data(can_id, false, x);

# send messages
interval:
  - interval: 1s
    then:
      lambda: |-
        if (id(can305Counter) > 30) {
          ESP_LOGI("main", "No rx can 0x305 reply since 30 sec, Inverter not connected/responding...");
          id(inverter_connected).publish_state(false);
          id(can305Counter) = 0;
        } else {
          id(can305Counter) ++;
        }

        if (id(noBmsUpdateCounter) > 30) {
          ESP_LOGI("main", "No rx from BMS since 30 sec, not connected/responding...");
          id(bms_connected).publish_state(false);
          id(noBmsUpdateCounter) = 0;
        } else {
          id(noBmsUpdateCounter) ++;
        }

sensor:
  - platform: homeassistant
    name: "jk soc"
    id: "jk_bms_soc"
    entity_id: sensor.jk_bms_state_of_charge

  - platform: homeassistant
    name: "pack_1_soc"
    id: "pack_1_soc"
    entity_id: sensor.deye_pcs_can_bus_pack_1_soc

  - platform: homeassistant
    name: "pack_2_soc"
    id: "pack_2_soc"
    entity_id: sensor.deye_pcs_can_bus_pack_2_soc

  - platform: template
    name: "Battery voltage"
    id: "battery_voltage"
    unit_of_measurement: 'V'
    device_class: 'voltage'
    state_class: 'measurement'
    accuracy_decimals: 2

  - platform: template
    name: "Battery current"
    id: "battery_current"
    unit_of_measurement: 'A'
    device_class: 'current'
    state_class: 'measurement'
    accuracy_decimals: 1

  - platform: template
    name: "Battery temperature"
    id: "battery_temperature"
    unit_of_measurement: '°C'
    device_class: 'temperature'
    state_class: 'measurement'
    accuracy_decimals: 1

  - platform: template
    name: "Battery charge voltage"
    id: "battery_charge_voltage"
    unit_of_measurement: 'V'
    device_class: 'voltage'
    state_class: 'measurement'
    accuracy_decimals: 2    

  - platform: template
    name: "Battery charge current limit"
    id: "battery_charge_current_limit"
    unit_of_measurement: 'A'
    device_class: 'current'
    state_class: 'measurement'
    accuracy_decimals: 0

  - platform: template
    name: "Battery discharge current limit"
    id: "battery_discharge_current_limit"
    unit_of_measurement: 'A'
    device_class: 'current'
    state_class: 'measurement'
    accuracy_decimals: 0

  - platform: template
    name: "Battery SoC"
    id: "battery_soc"
    unit_of_measurement: '%'
    device_class: 'battery'
    state_class: 'measurement'
    accuracy_decimals: 0

  - platform: template
    name: "Battery SoH"
    id: "battery_soh"
    unit_of_measurement: '%'
    device_class: 'battery'
    state_class: 'measurement'
    accuracy_decimals: 0

# Calculated power
  - platform: template
    name: "Battery power"
    id: "battery_power"
    unit_of_measurement: 'W'
    device_class: 'power'
    state_class: 'measurement'
    accuracy_decimals: 0   

binary_sensor:
    # 0x35C byte 0
  - platform: template
    name: "Charging allowed"
    id: "charging_allowed"

  - platform: template
    name: "Discharging allowed"
    id: "discharging_allowed"   

  - platform: template
    name: "Request force charge 1"
    id: "request_force_charge_1"

  - platform: template
    name: "Request force charge 2"
    id: "request_force_charge_2"

  - platform: template
    name: "Request full charge"
    id: "request_full_charge"

# CAN status
  - platform: template
    name: "Inverter connected"
    id: "inverter_connected"

  - platform: template
    name: "BMS connected"
    id: "bms_connected"

#Control
number:
  - platform: template
    name: "Set charge current limit"
    id: "set_charge_current_limit"
    unit_of_measurement: 'A'
    device_class: 'current'
    max_value: ${charge_current}
    min_value: 1
    step: 1
    optimistic: True
    restore_value: True
    
  - platform: template
    name: "Set discharge current limit"
    id: "set_discharge_current_limit"
    unit_of_measurement: 'A'
    device_class: 'current'
    max_value: ${discharge_current}
    min_value: 0
    step: 1
    optimistic: True
    restore_value: True

  - platform: template
    name: "Charge voltage offset"
    id: "charge_voltage_offset"
    unit_of_measurement: 'V'
    device_class: 'current'
    max_value: 1.0
    min_value: 0.0
    step: 0.1
    optimistic: True
    restore_value: True

  - platform: template
    name: "Charge voltage override"
    id: "charge_voltage_override"
    unit_of_measurement: 'V'
    device_class: 'voltage'
    max_value: 58.4
    min_value: 53.0
    step: 0.1
    optimistic: True
    restore_value: True

switch:
  - platform: template
    name: "Use Charge Current Override"
    id: use_charge_current_override
    optimistic: True
    restore_mode: ALWAYS_OFF

    # Add these new switches
  - platform: template
    name: "Block BMS Force Charge 1"
    id: "block_bms_force_charge_1"
    optimistic: True
    restore_mode: ALWAYS_OFF

  - platform: template
    name: "Block BMS Force Charge 2"
    id: "block_bms_force_charge_2"
    optimistic: True
    restore_mode: ALWAYS_OFF

  - platform: template
    name: "Override Force Charge 1"
    id: "override_force_charge_1"
    optimistic: True
    restore_mode: ALWAYS_OFF

  - platform: template
    name: "Override Force Charge 2"
    id: "override_force_charge_2"
    optimistic: True
    restore_mode: ALWAYS_OFF

  - platform: template
    name: "Set charging allowed"
    id: "set_charging_allowed"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON

  - platform: template
    name: "Set discharging allowed"
    id: "set_discharging_allowed"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON

  - platform: template
    name: "Set charge request"
    id: "set_charge_request"
    optimistic: True
    restore_mode: ALWAYS_OFF

  - platform: template
    name: "Charge to 90% only"
    id: "charge_to_90_only"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "SoC 100% (RCV+RFV) control"
    id: "soc_100_rcv_rfv_control"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: restart
    name: "Restart MitM-Deye"